### 冒泡排序

重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从小到大、首字母从从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。

思路：依次比较相邻的两个数，将比较小的数放在前面，比较大的数放在后面。

1. 第一次比较：首先比较第一和第二个数，将小数放在前面，将大数放在后面。
2. 比较第2和第3个数，将小数 放在前面，大数放在后面。
3. ......
4. 如此继续，直到比较到最后的两个数，将小数放在前面，大数放在后面，重复步骤，直至全部排序完成
5. 在上面一趟比较完成后，最后一个数一定是数组中最大的一个数，所以在比较第二趟的时候，最后一个数是不参加比较的。
6. 在第二趟比较完成后，倒数第二个数也一定是数组中倒数第二大数，所以在第三趟的比较中，最后两个数是不参与比较的。
7. 依次类推，每一趟比较次数减少一次。

如：[3, 2, 8, 5, 4, 1, 7, 6] 按从小到大排序

数1 | 数2 | 数3 | 数4 | 数5 | 数6 | 数7 | 数8
---|---|---|---|---|---|---|---|---
2 | 3 | 5 | 4 | 1 | 7 | 6 | 8
2 | 3 | 4 | 1 | 5 | 6 | 7 | 8
2 | 3 | 1 | 4 | 5 | 6 | 7 | 8
2 | 1 | 3 | 4 | 5 | 6 | 7 | 8
1 | 2 | 3 | 4 | 5 | 6 | 7 | 8

由上面例子可见第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，以此类推……也就是说，每进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。
<p style="color: #f00">N个数字要排序完成，最多需要进行N-1趟排序（如果很不幸地全部数值排序是完全从大到小的，但我们并不知道实际数字排序是怎样的，所以在算法上我们需要进行n-1次排序），每i趟的排序次数为(N-i)次</p>

上代码：

```js
let numErr=[3, 2, 8, 5, 4, 1, 7, 6];
 function bubblingSortarr(arr) {
  for(let i = 0, len = arr.length; i < len - 1; ++i) {
   for(let j = 0; j < len - 1 - i; ++j) {
    let nextIndex = j + 1;
    if(arr[j] > arr[nextIndex]) {
      [arr[j], arr[nextIndex]] = [arr[nextIndex], arr[j]]
    }
   }
  }
  return arr;
 }
 console.log(bubblingSortarr(numErr));
```

算法时间复制度
(PS:实际上面的代码对于案例中传入的数组在第五次排序时就已经完全排好了，多做了两次循环。 有没有大佬能知道怎么算出来最多需要几次排序就能排完的)

### 快速排序

快速排序（Quicksort）是对冒泡排序的一种改进。<br/>
快速排序由C. A. R. Hoare在1960年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。<br/>
实现步骤：

1. 在需要排序的数据中，选择一个元素作为基准值（一般选择第一个或中间的数）；
2. 所有小于基准值的元素归到一个集合，否则归到另一个集合；
3. 如果集合都只有一个元素，排序完成，否则对所有元素个数大于1的集合不断重复步骤1-3。

例： [4, 2, 6, 5, 1, 7, 3] <br/>
1. 首先取4作为基准值，第一次排序得到： <br/>
[[2, 1, 3], 4, [6, 5, 7]] <br/><br />
2. 对集合[2, 1, 3], [6, 5, 7]再次进行排序，得到：<br/>
[[1], 2, [3], 4, [5], 6, [7]] <br /><br />
3. 所有集合都只有一个元素，排序完成，得到：<br/>
[1, 2, 3, 4, 5, 6, 7] <br/>

上代码：

```js
let quickSort = function (arr) {
  if (arr.length <= 1) { return arr; } //如果数组长度小于等于1直接返回，终止递归
　var pivot = arr.splice(0, 1)[0];
　var leftArr = [];
　var rightArr = [];
　for (var i = 0; i < arr.length; i++){
　　if (arr[i] < pivot) {
　　　leftArr.push(arr[i]);
　　} else {
　　　rightArr.push(arr[i]);
　　}
　}
　return quickSort(left).concat([pivot], quickSort(right)); //递归调用
};
```
